#!/usr/bin/env bats   -*- bats -*-
#
# Regression test for flushing stale conntrack udp entries https://github.com/containers/netavark/issues/1045
#

load helpers

function start_sticky_udp_spammer() {
    target_port=10080
    target_ip=127.0.0.1
    local message=$1
    
    cat <<EOF > "$NETAVARK_TMPDIR/spammer.sh"
#!/bin/bash
# Open UDP connection to target on FD 3. 
# Keeps Source Port constant.
exec 3<>/dev/udp/$target_ip/$target_port
while true; do
    echo "$message" >&3
    sleep 0.1
done
EOF
    chmod +x "$NETAVARK_TMPDIR/spammer.sh"
    run_in_host_netns "$NETAVARK_TMPDIR/spammer.sh" &
    SPAMMER_PID=$!
}

function run_ct_udp_flush_test() {
    local config_file="${TESTSDIR}/testfiles/bridge-udp-stale-conntrack.json"
    local msg="payload_$$"

    start_sticky_udp_spammer "$msg"

    # avoid race condition and allow conntrack entry creation
    sleep 0.5

    run_in_host_netns conntrack -L
    assert "$output" =~ "dst=${target_ip}.*dport=${target_port}" "Conntrack flow matches target IP and Port"

    run_netavark --file "$config_file" setup $(get_container_netns_path)

    run_in_host_netns conntrack -L
    assert "$output" !~ "dst=${target_ip}.*dport=${target_port}" "Conntrack entry should NOT exist"

    run_in_container_netns timeout 1 sh -c "socat -u UDP4-LISTEN:8080 STDOUT | head -n 1"
    
    local container_output="$output"

    kill $SPAMMER_PID
    wait $SPAMMER_PID || true
    run_netavark --file "$config_file" teardown $(get_container_netns_path)

    assert "$container_output" =~ "$msg" "received proper payload"
}

@test "nftables: receive udp traffic with pre-existing stale conntrack entry" {
    export NETAVARK_FW="nftables"
    # Explicitly add a rule to trigger connection tracking.
    # This ensures the traffic generated by the spammer creates a conntrack entry that
    # Netavark must flush. Without this, the kernel might not track the flow, preventing
    # the reproduction of the stale entry issue (causing a false positive test pass).
    run_in_host_netns nft -f - <<EOF
add table inet bats {
    chain output {
        type filter hook output priority 0; policy accept;
        udp dport 10080 ct state new
    }
}
EOF
    run_ct_udp_flush_test
}

@test "firewalld: receive udp traffic with pre-existing stale conntrack entry" {
    setup_firewalld
    export NETAVARK_FW="firewalld"
    # Explicitly add a rule to trigger connection tracking.
    # This ensures the traffic generated by the spammer creates a conntrack entry that 
    # Netavark must flush. Without this, the kernel might not track the flow, preventing 
    # the reproduction of the stale entry issue (causing a false positive test pass).
    run_in_host_netns firewall-cmd --direct --add-rule ipv4 filter OUTPUT 0 -p udp -m state --state NEW -j ACCEPT
    run_ct_udp_flush_test
}
